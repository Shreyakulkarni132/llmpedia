{"id": "http://arxiv.org/abs/2209.07753v4", "guidislink": true, "link": "http://arxiv.org/abs/2209.07753v4", "updated": "2023-05-25T03:50:11Z", "updated_parsed": [2023, 5, 25, 3, 50, 11, 3, 145, 0], "published": "2022-09-16T07:17:23Z", "published_parsed": [2022, 9, 16, 7, 17, 23, 4, 259, 0], "title": "Code as Policies: Language Model Programs for Embodied Control", "title_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=code+as+policies++language+model+programs+for+embodied+control&id_list=&sortBy=relevance&sortOrder=descending&start=0&max_results=20", "value": "Code as Policies: Language Model Programs for Embodied Control"}, "summary": "Large language models (LLMs) trained on code completion have been shown to be\ncapable of synthesizing simple Python programs from docstrings [1]. We find\nthat these code-writing LLMs can be re-purposed to write robot policy code,\ngiven natural language commands. Specifically, policy code can express\nfunctions or feedback loops that process perception outputs (e.g.,from object\ndetectors [2], [3]) and parameterize control primitive APIs. When provided as\ninput several example language commands (formatted as comments) followed by\ncorresponding policy code (via few-shot prompting), LLMs can take in new\ncommands and autonomously re-compose API calls to generate new policy code\nrespectively. By chaining classic logic structures and referencing third-party\nlibraries (e.g., NumPy, Shapely) to perform arithmetic, LLMs used in this way\ncan write robot policies that (i) exhibit spatial-geometric reasoning, (ii)\ngeneralize to new instructions, and (iii) prescribe precise values (e.g.,\nvelocities) to ambiguous descriptions (\"faster\") depending on context (i.e.,\nbehavioral commonsense). This paper presents code as policies: a robot-centric\nformulation of language model generated programs (LMPs) that can represent\nreactive policies (e.g., impedance controllers), as well as waypoint-based\npolicies (vision-based pick and place, trajectory-based control), demonstrated\nacross multiple real robot platforms. Central to our approach is prompting\nhierarchical code-gen (recursively defining undefined functions), which can\nwrite more complex code and also improves state-of-the-art to solve 39.8% of\nproblems on the HumanEval [1] benchmark. Code and videos are available at\nhttps://code-as-policies.github.io", "summary_detail": {"type": "text/plain", "language": null, "base": "http://export.arxiv.org/api/query?search_query=code+as+policies++language+model+programs+for+embodied+control&id_list=&sortBy=relevance&sortOrder=descending&start=0&max_results=20", "value": "Large language models (LLMs) trained on code completion have been shown to be\ncapable of synthesizing simple Python programs from docstrings [1]. We find\nthat these code-writing LLMs can be re-purposed to write robot policy code,\ngiven natural language commands. Specifically, policy code can express\nfunctions or feedback loops that process perception outputs (e.g.,from object\ndetectors [2], [3]) and parameterize control primitive APIs. When provided as\ninput several example language commands (formatted as comments) followed by\ncorresponding policy code (via few-shot prompting), LLMs can take in new\ncommands and autonomously re-compose API calls to generate new policy code\nrespectively. By chaining classic logic structures and referencing third-party\nlibraries (e.g., NumPy, Shapely) to perform arithmetic, LLMs used in this way\ncan write robot policies that (i) exhibit spatial-geometric reasoning, (ii)\ngeneralize to new instructions, and (iii) prescribe precise values (e.g.,\nvelocities) to ambiguous descriptions (\"faster\") depending on context (i.e.,\nbehavioral commonsense). This paper presents code as policies: a robot-centric\nformulation of language model generated programs (LMPs) that can represent\nreactive policies (e.g., impedance controllers), as well as waypoint-based\npolicies (vision-based pick and place, trajectory-based control), demonstrated\nacross multiple real robot platforms. Central to our approach is prompting\nhierarchical code-gen (recursively defining undefined functions), which can\nwrite more complex code and also improves state-of-the-art to solve 39.8% of\nproblems on the HumanEval [1] benchmark. Code and videos are available at\nhttps://code-as-policies.github.io"}, "authors": [{"name": "Jacky Liang"}, {"name": "Wenlong Huang"}, {"name": "Fei Xia"}, {"name": "Peng Xu"}, {"name": "Karol Hausman"}, {"name": "Brian Ichter"}, {"name": "Pete Florence"}, {"name": "Andy Zeng"}], "author_detail": {"name": "Andy Zeng"}, "author": "Andy Zeng", "links": [{"href": "http://arxiv.org/abs/2209.07753v4", "rel": "alternate", "type": "text/html"}, {"title": "pdf", "href": "http://arxiv.org/pdf/2209.07753v4", "rel": "related", "type": "application/pdf"}], "arxiv_primary_category": {"term": "cs.RO", "scheme": "http://arxiv.org/schemas/atom"}, "tags": [{"term": "cs.RO", "scheme": "http://arxiv.org/schemas/atom", "label": null}]}